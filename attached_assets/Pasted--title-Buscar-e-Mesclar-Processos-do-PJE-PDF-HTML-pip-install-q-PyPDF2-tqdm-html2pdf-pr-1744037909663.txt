# @title üìÑ Buscar e Mesclar Processos do PJE (PDF + HTML)
!pip install -q PyPDF2 tqdm html2pdf
print("Bibliotecas instaladas com sucesso!")

# Importando as bibliotecas necess√°rias
import requests
import os
import io
import time
import pandas as pd
from tqdm.notebook import tqdm
import PyPDF2
from PyPDF2 import PdfMerger
import ipywidgets as widgets
from IPython.display import display, HTML, FileLink
import tempfile
import subprocess
from pathlib import Path
import sys
from io import StringIO

# Redirecionar sa√≠da padr√£o para capturar logs detalhados quando necess√°rio
original_stdout = sys.stdout

# Fun√ß√£o para autenticar e verificar acesso
def verificar_credenciais(cpf, senha):
    try:
        url_teste = f"https://machine-learning-toolkit-marcosmarf27.replit.app/api/v1/processo/teste"
        headers = {
            'X-MNI-CPF': cpf,
            'X-MNI-SENHA': senha
        }
        response = requests.get(url_teste, headers=headers)
        return response.status_code == 200
    except:
        return False

# Fun√ß√£o para obter detalhes do processo
def obter_detalhes_processo(numero_processo, cpf, senha):
    url = f"https://machine-learning-toolkit-marcosmarf27.replit.app/api/v1/processo/{numero_processo}"
    headers = {
        'X-MNI-CPF': cpf,
        'X-MNI-SENHA': senha
    }
    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            return response.json()
        else:
            return None
    except Exception as e:
        return None

# Fun√ß√£o para baixar documento
def baixar_documento(numero_processo, id_documento, cpf, senha):
    url = f"https://machine-learning-toolkit-marcosmarf27.replit.app/api/v1/processo/{numero_processo}/documento/{id_documento}"
    headers = {
        'X-MNI-CPF': cpf,
        'X-MNI-SENHA': senha
    }
    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            return response.content
        else:
            return None
    except Exception as e:
        return None

# Fun√ß√£o para converter HTML para PDF sem sa√≠da verbose
def html_para_pdf(html_content, output_path):
    # Redirecionar sa√≠da para capturar instala√ß√£o
    captured_output = StringIO()
    sys.stdout = captured_output

    try:
        !apt-get update -qq && apt-get install -qq -y wkhtmltopdf
    except:
        pass

    # Restaurar sa√≠da
    sys.stdout = original_stdout

    # Salvar o conte√∫do HTML em um arquivo tempor√°rio
    with tempfile.NamedTemporaryFile(suffix='.html', delete=False) as temp_html:
        temp_html.write(html_content)
        temp_html_path = temp_html.name

    # Converter HTML para PDF usando wkhtmltopdf silenciosamente
    try:
        subprocess.run(['wkhtmltopdf', '--quiet', temp_html_path, output_path],
                      check=True,
                      stdout=subprocess.DEVNULL,
                      stderr=subprocess.DEVNULL)
        result = True
    except subprocess.CalledProcessError:
        result = False

    # Remover arquivo tempor√°rio HTML
    os.unlink(temp_html_path)

    return result

# Fun√ß√£o principal para processar todos os processos
def processar_processos(lista_processos, cpf, senha):
    resultados = []
    arquivos_criados = []

    # Barra de progresso principal para os processos
    pbar_processos = tqdm(lista_processos, desc="Processando processos", unit="proc")

    for numero_processo in pbar_processos:
        # Limpar o n√∫mero do processo
        numero_processo = numero_processo.strip()

        # Atualizar descri√ß√£o da barra principal
        pbar_processos.set_description(f"Processo {numero_processo}")

        # Obter detalhes do processo
        detalhes = obter_detalhes_processo(numero_processo, cpf, senha)

        if not detalhes or not detalhes.get('sucesso', False):
            resultados.append({
                'numero_processo': numero_processo,
                'status': 'Falha',
                'mensagem': 'N√£o foi poss√≠vel obter detalhes do processo'
            })
            continue

        # Inicializar o PdfMerger para juntar os PDFs
        merger = PdfMerger()
        contador_docs = 0
        contador_html = 0

        # Para armazenar documentos que n√£o puderam ser baixados
        docs_falha = []

        # Diret√≥rio tempor√°rio para armazenar HTMLs convertidos em PDFs
        temp_dir = Path(tempfile.mkdtemp())

        # Extrair todos os documentos e documentos vinculados
        todos_documentos = []
        for documento in detalhes['processo']['documentos']:
            # Verificar se o documento principal √© PDF ou HTML
            if documento['mimetype'] in ['application/pdf', 'text/html']:
                todos_documentos.append({
                    'id': documento['idDocumento'],
                    'descricao': documento['descricao'],
                    'mimetype': documento['mimetype']
                })

            # Adicionar documentos vinculados
            if 'documentos_vinculados' in documento:
                for doc_vinc in documento['documentos_vinculados']:
                    if doc_vinc['mimetype'] in ['application/pdf', 'text/html']:
                        todos_documentos.append({
                            'id': doc_vinc['idDocumento'],
                            'descricao': doc_vinc['descricao'],
                            'mimetype': doc_vinc['mimetype']
                        })

        # Criar uma barra de progresso para o download de documentos
        pbar_docs = tqdm(total=len(todos_documentos), desc="Baixando documentos",
                        leave=False, unit="doc")

        # Baixar e mesclar todos os documentos
        for doc_info in todos_documentos:
            try:
                # Atualizar descri√ß√£o da barra de docs
                pbar_docs.set_description(f"Baixando doc {doc_info['id']}")

                doc_content = baixar_documento(numero_processo, doc_info['id'], cpf, senha)

                if doc_content:
                    try:
                        if doc_info['mimetype'] == 'application/pdf':
                            # Processar PDF
                            pdf_file = io.BytesIO(doc_content)
                            merger.append(pdf_file)
                            contador_docs += 1
                        elif doc_info['mimetype'] == 'text/html':
                            # Processar HTML
                            html_content = doc_content
                            temp_pdf_path = temp_dir / f"doc_{doc_info['id']}.pdf"

                            # Converter HTML para PDF
                            if html_para_pdf(html_content, str(temp_pdf_path)):
                                merger.append(str(temp_pdf_path))
                                contador_html += 1
                            else:
                                docs_falha.append(doc_info['id'])

                        # Pequena pausa para evitar sobrecarga na API
                        time.sleep(0.3)
                    except Exception:
                        docs_falha.append(doc_info['id'])
                else:
                    docs_falha.append(doc_info['id'])
            except Exception:
                docs_falha.append(doc_info['id'])

            # Atualizar progresso
            pbar_docs.update(1)

        # Fechar barra de progresso de docs
        pbar_docs.close()

        # Verificar se algum documento foi adicionado
        total_docs = contador_docs + contador_html
        if total_docs > 0:
            # Salvar o PDF mesclado
            nome_arquivo = f"{numero_processo.replace('.', '_').replace('-', '_')}.pdf"
            merger.write(nome_arquivo)
            merger.close()

            arquivos_criados.append((nome_arquivo, total_docs))

            resultados.append({
                'numero_processo': numero_processo,
                'status': 'Sucesso',
                'arquivo': nome_arquivo,
                'documentos_pdf': contador_docs,
                'documentos_html': contador_html,
                'documentos_falha': len(docs_falha)
            })
        else:
            resultados.append({
                'numero_processo': numero_processo,
                'status': 'Falha',
                'mensagem': 'Nenhum documento foi processado',
                'documentos_falha': len(docs_falha)
            })

        # Limpar os arquivos tempor√°rios
        for file in temp_dir.glob('*.pdf'):
            try:
                os.unlink(file)
            except:
                pass
        try:
            os.rmdir(temp_dir)
        except:
            pass

    return resultados, arquivos_criados

# Fun√ß√£o resumida para mostrar o resultado final
def mostrar_resultado_resumido(resultados):
    # Criar um resumo mais limpo
    sucessos = sum(1 for r in resultados if r['status'] == 'Sucesso')
    falhas = len(resultados) - sucessos
    total_docs = sum(r.get('documentos_pdf', 0) + r.get('documentos_html', 0)
                    for r in resultados if r['status'] == 'Sucesso')

    print(f"\n‚úÖ Resumo da opera√ß√£o:")
    print(f"   ‚Ä¢ Processos processados com sucesso: {sucessos}")
    print(f"   ‚Ä¢ Processos com falha: {falhas}")
    print(f"   ‚Ä¢ Total de documentos baixados: {total_docs}")

    # Retornar detalhes em DataFrame (sem exibir)
    return pd.DataFrame(resultados)

# Criar interface para o usu√°rio
def main_interface():
    # Widget para CPF e senha
    cpf_input = widgets.Text(description='CPF:', placeholder='Digite seu CPF')
    senha_input = widgets.Password(description='Senha:', placeholder='Digite sua senha')

    # Widget para lista de processos
    processos_input = widgets.Textarea(
        description='Processos:',
        placeholder='Digite os n√∫meros de processo (um por linha)',
        layout=widgets.Layout(width='80%', height='120px')
    )

    # Bot√£o de submiss√£o
    submit_btn = widgets.Button(description='Buscar e Mesclar Documentos',
                               button_style='primary',
                               icon='search')

    # √Årea para exibir resultados
    output = widgets.Output()
    links_output = widgets.Output()
    detalhes_output = widgets.Output()

    # Bot√£o para mostrar/ocultar detalhes
    detalhes_btn = widgets.Button(
        description='Mostrar Detalhes',
        button_style='info',
        disabled=True,
        layout=widgets.Layout(display='none')
    )

    # Fun√ß√£o para executar quando o bot√£o for clicado
    def on_submit_clicked(b):
        with output:
            output.clear_output()
            links_output.clear_output()
            detalhes_output.clear_output()

            # Ocultar bot√£o de detalhes
            detalhes_btn.layout.display = 'none'
            detalhes_btn.disabled = True

            cpf = cpf_input.value.strip()
            senha = senha_input.value
            processos_text = processos_input.value.strip()

            # Validar entradas
            if not cpf or not senha or not processos_text:
                print("Por favor, preencha todos os campos.")
                return

            # Valida√ß√£o simples de CPF
            if len(cpf) != 11 or not cpf.isdigit():
                print("CPF inv√°lido. Digite apenas os 11 n√∫meros sem pontos ou tra√ßos.")
                return

            # Extrair lista de processos
            lista_processos = [p.strip() for p in processos_text.split('\n') if p.strip()]

            if not lista_processos:
                print("Por favor, adicione pelo menos um n√∫mero de processo.")
                return

            print(f"Iniciando processamento de {len(lista_processos)} processo(s)...")

            # Processar os dados
            resultados, arquivos_criados = processar_processos(lista_processos, cpf, senha)

            # Mostrar resumo simplificado
            df_resultados = mostrar_resultado_resumido(resultados)

            # Habilitar bot√£o de detalhes
            if not df_resultados.empty:
                detalhes_btn.layout.display = 'block'
                detalhes_btn.disabled = False

            # Armazenar DataFrame para mostrar detalhes depois
            detalhes_btn.df = df_resultados

            # Mostra links para os arquivos
            with links_output:
                if arquivos_criados:
                    print("\nüìÇ Arquivos criados:")
                    for nome_arquivo, contador_docs in arquivos_criados:
                        # Cria um link para o arquivo
                        display(HTML(f"<p>‚Ä¢ <b>{nome_arquivo}</b> ({contador_docs} documentos) - "
                                   f"<a href='files/{nome_arquivo}' target='_blank'>Visualizar</a></p>"))

    # Fun√ß√£o para mostrar detalhes quando solicitado
    def on_detalhes_clicked(b):
        with detalhes_output:
            detalhes_output.clear_output()
            display(HTML("<h3>üìã Detalhes do processamento</h3>"))
            display(b.df)

    # Conectar os bot√µes √†s fun√ß√µes
    submit_btn.on_click(on_submit_clicked)
    detalhes_btn.on_click(on_detalhes_clicked)

    # Montar os widgets
    display(HTML("<h2>üìÑ Download e Mesclagem de Documentos do PJE</h2>"))
    display(HTML("<p>Este aplicativo baixa e mescla documentos PDF e HTML do sistema PJE em um √∫nico arquivo PDF por processo.</p>"))
    display(cpf_input)
    display(senha_input)
    display(processos_input)
    display(submit_btn)
    display(output)
    display(links_output)
    display(detalhes_btn)
    display(detalhes_output)

# Iniciar a interface
main_interface()